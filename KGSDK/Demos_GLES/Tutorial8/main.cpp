//=======================================================================
//Tutorial 8: Applying Mathematics (Sin/Cos/Pi)

//--------------------------------------------
//File:			main.cpp
//Description:	Applies Advanced Trigonometry (Sine Wave), to 
//				a deformed rectangle, to create a waving flag
//				effect
//
//Author: King (King@Gizmondoforums.com)
//Copyright (c) GizzedINC. All rights reserved.
//=======================================================================

#include "Functions.h"	// Non-relevant drawing code in this header	

//--------------------------------------------------------------------------------------------------------------------------------------

void Flag_Init()
{
	int x;		//Current X Cell Index
	int y;		//Current Y Cell Index
	int apos;	//Current X Position

	for (y = 0; y < 10; y++)	//Loop through each Row
	{
		for (x = 0, apos = 0; x < 18; x++, apos += 2)	//Loop through each Column
		{
			flagPoints[y][apos][0] = float(x);			//X value
			flagPoints[y][apos][1] = float(y + 1);		//1 above the Y value
			flagPoints[y][apos][2] = float(sin(x * PERIOD * PIOVER180)) * AMPLITUDE;
			// Z value generated by sin wave.

			flagCoords[y][apos][0] = x * 1.0f / 18.0f;			//X Texcoord
			flagCoords[y][apos][1] = (y + 1) * 1.0f / 10.0f;	//Y TexCoord
			//Specify Texture co-ordinates for current cell
			
			//Next section of code is a repeat of prevoius block, except
			//that it operates on the next apos value. Y value is also 
			//different in the section below
			flagPoints[y][apos + 1][0] = float(x);
			flagPoints[y][apos + 1][1] = float(y);
			flagPoints[y][apos + 1][2] = float(sin(x * PERIOD * PIOVER180)) * AMPLITUDE;


			flagCoords[y][apos + 1][0] = x * 1.0f / 18.0f;
			flagCoords[y][apos + 1][1] = y * 1.0f / 10.0f;
		}
	}
}

//--------------------------------------------------------------------------------------------------------------------------------------

void Init()
{
	glEnable(GL_LIGHTING);		//Enable Lighting
	glEnable(GL_LIGHT0);		//Enable GL_LIGHT0
	glEnable(GL_COLOR_MATERIAL);//Enable GL_LIGHT0
	glDisable(GL_CULL_FACE);	//Disable Back face culling

	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, matAmbient);	
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, matDiffuse);

	glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmbient);	
	glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiffuse);

	if (!LoadTextures())	
	{
		MessageBox(NULL, L"Error loading textures", L"Error", MB_OK);
	}
	else
	{
		glEnable(GL_TEXTURE_2D);
	}

	Flag_Init();				//Intialise Flag

	glLoadIdentity();
		
	GLfixed mat[4][4];

	float nearz, farz;

	farz  = 300.0f;
	nearz = 0.01f;

	memset(mat, 0, sizeof(mat));
	mat[0][0] = (int) (65536.0f * 2.4f);
	mat[1][1] = (int) (65536.0f * 3.2f);
	mat[2][2] = (int) (65536.0f * (farz / (farz - nearz)));
	mat[2][3] = (int) (65536.0f * 1.0f);
	mat[3][2] = (int) (65536.0f * ((-farz * nearz) / (farz - nearz)));

	glMatrixMode(GL_PROJECTION);
	glLoadMatrixx(&mat[0][0]);

	rot[0] = 0;
	rot[1] = 0;
	rot[2] = 0;
	loc[0] = 0;
	loc[1] = 0;
	loc[2] = 3;

	glVertexPointer(3, GL_FLOAT, 0, flagPoints);
	glTexCoordPointer(2, GL_FLOAT, 0, flagCoords);
	glEnableClientState(GL_VERTEX_ARRAY);
	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
}

//--------------------------------------------------------------------------------------------------------------------------------------

void DrawFlag()
{
	glRotatef(xrot,1.0f,0.0f,0.0f);	//Rotate axis based on value of xrot
	glRotatef(yrot,0.0f,1.0f,0.0f);	//Rotate axis based on value of yrot
	

	glPushMatrix();

		glScalef(0.07f, 0.07f, 0.07f);		//Scale Down the Flag
		glTranslatef(-10.0f, -5.0f, 0.0f);	//Translate the flag to the center of the screen

		for (int i = 0; i < 10; i++)		
			glDrawArrays(wireFrame ? GL_LINE_STRIP : GL_TRIANGLE_STRIP, i * 36, 36);
		//Draw the flag onto the screen in regard to wireframe status

	glPopMatrix();
}

//--------------------------------------------------------------------------------------------------------------------------------------

void Render()
{
	glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	DrawFlag();	//Draw Flag to screen
	
	glFinish();
	eglSwapBuffers(FrameworkGL_GetDisplay(), FrameworkGL_GetSurface());
}

//--------------------------------------------------------------------------------------------------------------------------------------

void Update()
{
	GLfixed mat[4][4];

	memset(mat, 0, sizeof(mat));
	mat[0][0] = (int) (65536.0f *  cos(rot[0]));
	mat[0][2] = (int) (65536.0f *  sin(rot[0]));
	mat[1][1] = (int) (65536.0f *  cos(rot[1]));
	mat[1][2] = (int) (65536.0f *  sin(rot[1]));
	mat[2][0] = (int) (65536.0f * -sin(rot[0]) * cos(rot[1]));
	mat[2][2] = (int) (65536.0f *  cos(rot[0]) * cos(rot[1]));
	mat[3][2] = (int) (65536.0f * loc[2]);
	mat[3][3] = 65536;
	
	glMatrixMode(GL_MODELVIEW);
	glLoadMatrixx(&mat[0][0]);

	if (Framework_IsButtonPressed(FRAMEWORK_BUTTON_LEFT_SHOULDER )) 
		loc[2] += 0.3f; 
	// If the Left Shoulder Button has been pressed: Zoom out
	if (Framework_IsButtonPressed(FRAMEWORK_BUTTON_RIGHT_SHOULDER)) 
		loc[2] -= 0.3f;
	// If the Right Shoulder Button has been pressed: Zoom In
	if (Framework_IsButtonPressed(FRAMEWORK_BUTTON_DPAD_DOWN     )) 
		xrot -= 1.0f;
	// If the Down button (DPAD) has been pressed: Rotate the Flag downards
	if (Framework_IsButtonPressed(FRAMEWORK_BUTTON_DPAD_UP	     )) 
		xrot += 1.0f;
	// If the Up button (DPAD) has been pressed: Rotate the Flag upwards
	if (Framework_IsButtonPressed(FRAMEWORK_BUTTON_DPAD_LEFT     )) 
		yrot -= 1.0f;
	// If the Left button (DPAD) has been pressed: Rotate the Flag towards the left
	if (Framework_IsButtonPressed(FRAMEWORK_BUTTON_DPAD_RIGHT	 )) 
		yrot += 1.0f;
	// If the Right button (DPAD) has been pressed: Rotate the Flag towards the Right
	if (Framework_IsButtonPressed(FRAMEWORK_BUTTON_FORWARD		 )) 
	{
		wrapValue = flagPoints[0][35][2];	//Select z value from last column

		for (int y = 0; y < 10; y++)		//Loop through each Row
		{
			for (int x = 35; x > 0; x -= 2)	//Loop through each Column, except last (in revrse order)
			{
				flagPoints[y][x][2] = flagPoints[y][x-2][2];
				flagPoints[y][x-1][2] = flagPoints[y][x-3][2];
				//Assign the current value, the one before it
			}

			flagPoints[y][0][2] = wrapValue;
			flagPoints[y][1][2] = wrapValue;
			//Assign the first column, the value of the last column
		}
	}
	// If the Forward has been pressed: Wave the Flag

	if (Framework_IsButtonPressed(FRAMEWORK_BUTTON_REWIND	 )) 
		wireFrame =! wireFrame;

	// If the Rewind has been pressed: Toggle Wire Frame mode
}

//--------------------------------------------------------------------------------------------------------------------------------------

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )
{
	if (!Framework_Init(hInstance, hPrevInstance))
	{
		return 0;
	}

	if (!FrameworkGL_Init())
	{
		Framework_Close();
		return 0;
	}

	Init();

	do
	{
		Render();
		Update();
		Framework_ProcessMessages();

		if (!Framework_IsAppActive())
		{
			while (!Framework_IsAppActive())
			{
				Framework_ProcessMessages();
				Sleep(50);
			}
		}

	} while (!Framework_IsButtonPressed(FRAMEWORK_BUTTON_HOME));

	FrameworkGL_Close();
	Framework_Close();

	return 0;
}